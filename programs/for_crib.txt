Чтобы итерировать задом на перед - for _ in range(len(итерируемый объект) - 1, len(итерируемый объект) -1 + 1)




Необходимо использовать остаток от деления (оператор "%"), чтобы на последней итерации (когда i = len(numbers) - 1) вот этот участок кода:

numbers[(i + 1)]

не вызвал исключения из-за выхода за границы списка. Нам необходимо обратиться к соседу справа - по условию задачи это будет первый элемент (под индексом 0).
Конечно, это проблему можно обойти используя оператор if, но так же красивее)
Верное решение #29660537


numbers = [int(i) for i in input().split()]
if len(numbers) == 1:
    print(numbers[0])
else:
    for i in range(len(numbers)):
        print(numbers[i - 1] + numbers[(i + 1) % len(numbers)], end=" ")    